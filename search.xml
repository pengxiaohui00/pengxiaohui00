<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二叉树遍历]]></title>
    <url>%2F2018%2F06%2F05%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[#了解：js可通过数组内置方法push与shift实现队列；通过push与pop实现栈； #构造二叉树12345function Node() &#123; this.value = null this.left = null this.right = null&#125; #生成一个二叉树列子；123456789101112131415161718192021222324var tree = &#123; value: 10, left: &#123; value: 2, left: &#123; value: 4 &#125; &#125;, right: &#123; value: 11, left: &#123; value: 9, left: &#123; value: 5 &#125;, right: &#123; value: 12 &#125; &#125;, right: &#123; value: 14 &#125; &#125;&#125; #广度优先遍历(队列) 从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止 入队根节点、取出，入队左节点、队右节点；取出左节点，取出右节点；1234567891011 let leverOrder=function(node)&#123; let que=[]; que.push(node) while(que.length!==0)&#123; node =que.shift() console.log(node.value) if(node.left) que.push(node.left); if(node.right) que.push(node.right); &#125; &#125;levelOrder(tree);// 10 2 11 4 9 14 5 12 #深度优先遍历（栈） 沿着树的深度遍历树的节点，尽可能深的搜索树的分支。 当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。 这一过程一直进行到已发现从源节点可达的所有节点为止。 如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止#O代表访问根节点：L代表访问左节点：R代表访问右节点；#先序遍历：OLR（递归） 12345678var preOrder = function (node) &#123; if (node) &#123; console.log(node.value); preOrder(node.left); preOrder(node.right); &#125;&#125;;preOrder(tree);//10 2 4 11 9 5 12 14 #栈先推入根节点入栈、取出，再推右节点、左节点入栈，取出；123456789101112let preOrder= function (node) &#123; let stack =[]; stack.push(node); while(stack.length!==0)&#123; node =stack.pop(); console.log(node.value); if(node.right) stack.push(node.right); if(node.left) stack.push(node.left); &#125;&#125; preOrder(tree)//10 2 4 11 9 5 12 14 #中序遍历：LOR（） ##递归12345678var inOrder = function (node) &#123; if (node) &#123; inOrder(node.left); console.log(node.value); inOrder(node.right); &#125;&#125;inOrder(tree);// 4 2 10 5 9 12 11 14 ##栈先把根节点、左节点推入栈，然后取出左节点，再推右节点入栈，取出根节点与右节点；1234567891011121314 let inOrder=function (node)&#123; stack=[]; while(stack.length!==0||node )&#123; if(node)&#123; stack.push(node); node=node.left ; &#125;else&#123; node = stack.pop(); console.log(node.value); node= node.right; &#125; &#125; &#125;inOrder(tree)// 4 2 10 5 9 12 11 14 #后序遍历：LRO ##递归12345678var postOrder = function (node) &#123; if (node) &#123; postOrder(node.left); postOrder(node.right); console.log(node.value); &#125;&#125;postOrder(tree);// 4 2 5 12 9 14 11 10 ##栈定义2个栈是s1,s2：s1暂存数据：先把根节点和左树推入栈，然后取出左树，再推入右树，取出，最后取根节点。12345678910111213141516let postOrder= function (node)&#123; let s1=[]; let s2=[]; s1.push(node); while(s1.length!==0) &#123; node = s1.pop(); s2.push(node); if (node.left) s1.push(node.left); if (node.right) s1.push(node.right); &#125; while(s2.length!==0)&#123; console.log(s2.pop().value); &#125;&#125; postOrder(tree)//4 2 5 12 9 14 11 10 #用递归能做的,用非递归都可以做. 因为递归其实就是利用函数栈来保存信息,如果用自己的数据结构来代替函数栈,自然可以实现相同的功能. 如果需要用队列实现深度遍历，我的思路是用两个队列模拟一个栈。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2018%2F05%2F05%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[#字典排序1234let dict = &#123;f: 3, b:1, c:2,a:&#123;c:1,b:3,a:6&#125;&#125;;for (let key of Object.keys(dict).sort()) &#123; console.log(key, dict[key]);&#125; 冒泡排序12345678910111213141516 var bubbleSort = function (arr) &#123; var length = arr.length; for(var i=0;i&lt;length-1;i++)&#123; for (var j= 0;j&lt;length-1-i;j++)&#123; if(arr[j] &gt;arr[j+1])&#123; var aux =arr[j]; arr[j] = arr[j+1]; arr[j+1]= aux; &#125; &#125; &#125; return arr;&#125;;var arr1=[3,1,2,6,8,9,3,4,14,11,"a","h","c","b"];console.log(arr1);console.log(bubbleSort(arr1)); #选择排序12345678910111213141516171819 var selectionSort = function (arr) &#123; var length = arr.length,indexMin; for (var i=0;i&lt;length-1;i++)&#123; indexMin =i; for (var j=i;j&lt;length;j++)&#123; if(arr[indexMin]&gt;arr[j])&#123; indexMin = j; &#125; &#125; if(i !==indexMin)&#123; var aux =arr[i]; arr[i] = arr[indexMin]; arr[indexMin]= aux; &#125; &#125; return arr; &#125;var arr2=[3,1,2,6,8,9,3,4,14,11,"a","h","c","b"]; console.log(selectionSort(arr2)); #插入排序12345678910111213141516 var insertionSort = function(arr)&#123; var len = arr.length; var j,temp; for( var i=1;i&lt;len;i++)&#123; j=i; temp =arr[i]; while(j&gt; 0 &amp;&amp; arr[j-1]&gt;temp)&#123; arr[j]=arr[j-1]; j--; &#125; arr[j]=temp; &#125; return arr; &#125;var arr3=[3,1,2,6,8,9,3,4,14,11,"a","h","c","b"];console.log(insertionSort(arr3)); #归并排序12345678910111213141516171819202122function merge(left, right) &#123; var tmp = []; while (left.length &amp;&amp; right.length) &#123; if (left[0] &lt; right[0]) tmp.push(left.shift()); else tmp.push(right.shift()); &#125; return tmp.concat(left, right);&#125;function mergeSort(a) &#123; if (a.length === 1) return a; var mid = Math.floor(a.length / 2) , left = a.slice(0, mid) , right = a.slice(mid); console.log(left); console.log(right); return merge(mergeSort(left), mergeSort(right));&#125;var arr4=[3,1,2,6,8,9,3,4,14,11,"a","h","c","b"];console.log(mergeSort(arr4)); 快速排序1234567891011121314151617181920 function quickSort(a) &#123; if (a.length &lt;= 1) return a; var mid = Math.floor(a.length / 2) , midItem = a.splice(mid, 1)[0] , left = [] , right = []; a.forEach(function(item) &#123; if (item &lt;= midItem) left.push(item); else right.push(item); &#125;); var _left = quickSort(left), _right = quickSort(right); console.log(_left) console.log(_right) return _left.concat(midItem, _right); &#125;var arr5 = [6,8,9,3,"a",11,"h",3,"c"];console.log(quickSort(arr5)) 数组内置方法123console.log(arr5.sort(function(v1,v2)&#123; return v1 &gt; v2;&#125;))]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承]]></title>
    <url>%2F2018%2F05%2F01%2F%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[继承JavaScript并不提供原生的继承机制，我们自己实现的方式很多，介绍一种最为通用的 先定义两个类12345678910111213141516function Person(name, sex)&#123; this.name = name; this.sex = sex;&#125;Person.prototype.printName = function()&#123; console.log(this.name);&#125;;function Male(age)&#123; this.age = age;&#125;Male.prototype.printAge = function()&#123; console.log(this.age);&#125;; 属性获取对象属性的获取是通过构造函数的执行，我们在一个类中执行另外一个类的构造函数，就可以把属性赋值到自己内部，但是我们需要把环境改到自己的作用域内，这就要借助我们讲过的函数call了 改造一些Male12345678function Male(name, sex, age)&#123; Person.call(this, name, sex); this.age = age;&#125;Male.prototype.printAge = function()&#123; console.log(this.age);&#125;; 实例化看看结果12var m = new Male('Byron', 'male', 26);console.log(m.sex); // "male" 方法获取我们知道类的方法都定义在了prototype里面，所以只要我们把子类的prototype改为父类的prototype的备份就好了1Male.prototype = Object.create(Person.prototype); 这里我们通过Object.createclone了一个新的prototype而不是直接把Person.prtotype直接赋值，因为引用关系，这样会导致后续修改子类的prototype也修改了父类的prototype，因为修改的是一个值 另外Object.create是ES5方法，之前版本通过遍历属性也可以实现浅拷贝 这样做需要注意一点就是对子类添加方法，必须在修改其prototype之后，如果在之前会被覆盖掉 12345Male.prototype.printAge = function()&#123; console.log(this.age);&#125;;Male.prototype = Object.create(Person.prototype); 这样的话，printAge方法在赋值后就没了，因此得这么写12345678910function Male(name, sex, age)&#123; Person.call(this, name, sex); this.age = age;&#125;Male.prototype = Object.create(Person.prototype);Male.prototype.printAge = function()&#123; console.log(this.age);&#125;; 这样写貌似没问题了，但是有个问题就是我们知道prototype对象有一个属性constructor指向其类型，因为我们复制的父元素的prototype，这时候constructor属性指向是不对的，导致我们判断类型出错1Male.prototype.constructor; //Person 因此我们需要再重新指定一下constructor属性到自己的类型 最终方案我们可以通过一个函数实现刚才说的内容12345function inherit(superType, subType)&#123; var _prototype = Object.create(superType.prototype); _prototype.constructor = subType; subType.prototype = _prototype;&#125; 使用方式12345678910111213141516171819202122function Person(name, sex)&#123; this.name = name; this.sex = sex;&#125;Person.prototype.printName = function()&#123; console.log(this.name);&#125;;function Male(name, sex, age)&#123; Person.call(this, name, sex); this.age = age;&#125;inherit(Person, Male);// 在继承函数之后写自己的方法，否则会被覆盖Male.prototype.printAge = function()&#123; console.log(this.age);&#125;;var m = new Male('Byron', 'm', 26);m.printName(); es5之前方法1234567891011121314151617181920212223function Person(name, sex)&#123; this.name = name; this.sex = sex;&#125;Person.prototype.printName = function()&#123; console.log(this.name);&#125;;function Male(name, sex, age)&#123; Person.call(this, name, sex); this.age = age;&#125;Male.prototype =Person new;（）Male.prototype.constructor = Male;// 在继承函数之后写自己的方法，否则会被覆盖Male.prototype.printAge = function()&#123; console.log(this.age);&#125;;var m = new Male('Byron', 'm', 26);m.printName(); es6 类 :extends 关键字1234567891011121314class Animal&#123; constructor()&#123; this.body = '肉体' &#125;, move()&#123;&#125;&#125;class Human extends Animal&#123; constructor(name)&#123; super() this.name = name &#125;, useTools()&#123;&#125;&#125;var frank = new Human() 这样我们就在JavaScript中实现了继承 hasOwnPropertyhasOwnPerperty是Object.prototype的一个方法，可以判断一个对象是否包含自定义属性而不是原型链上的属性，hasOwnProperty是JavaScript中唯一一个处理属性但是不查找原型链的函数 123m.hasOwnProperty('name'); // truem.hasOwnProperty('printName'); // falseMale.prototype.hasOwnProperty('printAge'); // true 范例 1.实现面向对象的方式实现 Tab 组件代码地址 2.扩展 String 的功能增加 reverse 方法，实现字符串倒序1234567String.prototype.reverse = function()&#123; return this.split("").reverse().join("") console.log(this) &#125;; var str = 'hello jirengu' var str2 = str.reverse(); console.log(str2) // 'ugnerij olleh']]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解作用链]]></title>
    <url>%2F2018%2F04%2F15%2F%E7%90%86%E8%A7%A3%E4%BD%9C%E7%94%A8%E9%93%BE%2F</url>
    <content type="text"><![CDATA[#理解作用链的作用 1.函数在执行的过程中，先从自己内部找变量 2.如果找不到，再从创建当前函数所在的作用域去找, 以此往上 3.注意找的是变量的当前的状态 范例1234567891011121314var a = 1function fn1()&#123; function fn2()&#123; console.log(a) &#125; function fn3()&#123; var a = 4 fn2() &#125; var a = 2 return fn3&#125;var fn = fn1()fn() //2 最后执行fn2函数，fn2找不到变量a,接着往上在找到创建当前fn2所在的作用域fn1中找到a=2;1234567891011121314var a = 1function fn1()&#123; function fn3()&#123; var a = 4 fn2() &#125; var a = 2 return fn3&#125;function fn2()&#123; console.log(a)&#125;var fn = fn1()fn() //1 同上123456789101112131415var a = 1function fn1()&#123; function fn3()&#123; function fn2()&#123; console.log(a) &#125; fn2() var a = 4 &#125; var a = 2 return fn3&#125;var fn = fn1()fn() //undefined 函数fn2在执行的过程中，先从自己内部找变量找不到，再从创建当前函数所在的作用域fn去找,注意此时变量声明前置，a已声明但未初始化为undefined; #理解作用链的原理：前提：了解全局作用域，函数作用域，变量和函数的声明前置等基础； ##函数的生命周期 ###函数的的生命周期分为创建和执行两个阶段。 在函数创建阶段，JS解析引擎进行预解析，会将函数声明提前，同时将该函数放到全局作用域中或当前函数的上一级函数的局部作用域中。 在函数执行阶段，JS引擎会将当前函数的局部变量和内部函数进行声明提前，然后再执行业务代码，当函数执行完退出时，释放该函数的执行上下文，并注销该函数的局部变量。##变量对象（Variable Object） VO对应的是函数创建阶段，JS解析引擎进行预解析时，所有的变量和函数的声明，统称为Variable Object。 该变量与执行上下文相关，知道自己的数据存储在哪里，并且知道如何访问。 ##VO是一个与执行上下文相关的特殊对象，它存储着在上下文中声明的以下内容： 变量 (var, 变量声明); 函数声明 (FunctionDeclaration, 缩写为FD); 函数的形参12345678function add(a,b)&#123; var sum = a + b; function say()&#123; alert(sum); &#125; return sum;&#125;// sum,say,a,b 组合的对象就是VO ##AO（活动对象） 对应的是函数执行阶段，当函数被调用执行时，会建立一个执行上下文，该执行上下文包含了函数所需的所有变量，该变量共同组成了一个新的对象就是Activetion Object。 该对象包含了： 函数的所有局部变量 函数的所有命名参数 函数的参数集合 函数的this指向123456789101112131415161718unction add(a,b)&#123; var sum = a + b; function say()&#123; alert(sum); &#125; return sum;&#125;add(4,5);// 我用JS对象来表示AO// AO = &#123;// this : window,// arguments : [4,5],// a : 4,// b : 5,// say : ,// sum : undefined// &#125; 作用域链 1.当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）来保证对执行环境有权访问的变量和函数的有序访问。 2.作用域第一个对象始终是当前执行代码所在环境的变量对象（VO），即在当前执行函数的作用域中寻找变量。 3.在函数运行过程中标识符的解析是沿着作用域链一级一级搜索的过程，从第一个对象开始，逐级向后回溯，直到找到同名标识符为止，找到后不再继续遍历，找不到就报错。 举例： 1 预处理后，进入全局上下文 2 执行bar()函数 3 查找变量 4 执行foo()函数]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型与原型链]]></title>
    <url>%2F2018%2F04%2F02%2F%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[prototype（原型）12345678910function Person(nick, age)&#123; this.nick = nick; this.age = age;&#125;Person.prototype.sayName = function()&#123; console.log(this.nick);&#125;var p1 = new Person();p1.sayName(); 我们通过函数定义了类Person，类（函数）自动获得属性prototype 每个类的实例都会有一个内部属性proto，指向类的prototype属性 通过图示我们可以看出一些端倪，实例可以通过__prop__访问到其类型的prototype属性，这就意味 着类的prototype对象可以作为一个公共容器，供所有实例访问。 原型链我们刚才的问题可以通过这个手段解决 所有实例都会通过原型链引用到类型的prototype prototype相当于特定类型所有实例都可以访问到的一个公共容器 重复的东西移动到公共容器里放一份就可以了 范例 12345678910function People (name)&#123; this.name = name;&#125;People.prototype.walk = function()&#123; console.log(this.name + ' is walking');&#125;var p1 = new People('饥人谷');var p2 = new People('前端'); 这时候我们对应的关系是这样的 深入了解原型链]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web安全]]></title>
    <url>%2F2018%2F03%2F25%2Fweb%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[XSS 攻击XSS攻击全称跨站脚本攻击，是为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS，XSS是一种在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。其实在web前端方面，可以简单的理解为一种javascript代码注入。 使用eval 有什么问题？需要注意的地方就是eval这个函数是可以将字符串重新转换成函数的并且执行函数的。eval() 函数：可计算某个字符串,并执行其中的的 JavaScript 代码。 ##如何防范 XSS 攻击？ 1.js 里不要用 eval 2.不要用 innerHTML，尽量使用innerText 3.把敏感信息都是存储在cookie中的（不要把用户机密信息放在网页中），想要阻止黑客通过js访问到cookie中的用户敏感信息。那么请使用cookie的HttpOnly属性，加上了这个属性的cookie字段，js是无法进行读写的。 4.只允许用户输入我们期望的数据。例如：年龄的textbox中，只允许用户输入数字，而数字之外的字符都过滤掉 5.对数据进行Html Encode 处理。一般会转（&amp;、&lt;、&gt;、”、’、/）这6个字符； CSRF 攻击CSRF（Cross-site request forgery，中文为跨站请求伪造）是一种利用网站可信用户的权限去执行未授权的命令的一种恶意攻击。通过伪装可信用户的请求来利用信任该用户的网站 如何防范？1.验证 HTTP Referer 字段HTTP头中的Referer字段记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，而如果黑客要对其实施 CSRF 攻击，他一般只能在他自己的网站构造请求。因此，可以通过验证Referer值来防御CSRF 攻击。 2.在请求中添加token并验证CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于cookie中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有token或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于session之中，然后在每次请求时把token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 http://url?csrftoken=tokenvalue。不行，不安全，可能会被攻击者看到。而对于 POST 请求来说，要在 form 的最后加上&lt;input type=&quot;hidden&quot; name=&quot;csrftoken&quot; value=&quot;tokenvalue&quot;/&gt;这样就把token以参数的形式加入请求了。 3.在HTTP 头中自定义属性并验证这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。 4.验证码。通常情况下，验证码能够很好的遏制CSRF攻击，但是很多情况下，出于用户体验考虑，验证码只能作为一种辅助手段，而不是最主要的解决方案。 Https 是如何保证安全的？ （1） 对称加密加密与解密使用的是同样的密钥，所以速度快，但由于需要将密钥在网络传输，所以安全性不高。 （2） 非对称加密使用一对密钥，公钥与私钥，所以安全性高，但加密与解密速度慢。 （3） 解决的办法是将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通。 (4)系统中会预先安装好证书，进行https通讯前会核对公钥是否在传输中被篡改。不信任一些不可靠证书。 具体流程: 服务器 用RSA生成公钥和私钥 把公钥放在证书里发送给客户端，私钥自己保存 客户端首先向一个权威的服务器检查证书的合法性 如果证书合法，客户端产生一段随机数，这个- 随机数就作为通信的密钥，我们称之为对称密钥 用公钥加密这段随机数，然后发送到服务器，服务器用密钥解密获取对称密钥，然后，双方就已对称密钥进行加密解密通信了]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用css选择器]]></title>
    <url>%2F2018%2F03%2F25%2F%E5%B8%B8%E7%94%A8css%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[#CSS常用选择器： ##一、简单选择器 *，通用元素选择器，匹配任何元素E，标签选择器，匹配所有使用E标签的元素.class，class选择器，匹配特定class属性的元素 /#ID，id选择器，匹配特定id属性的元素 ##二、属性选择器[atrr] ，选择包含 attr 属性的所有元素，不论 attr 的值为何[attr=val] ，仅选择 attr 属性被赋值为 val 的所有元素 ##三、组合选择器A, B ，多元素选择器：选中匹配 A 或B 元素A B ，后代选择器：选中匹配 A 元素的后代B 元素(A B之间空格分开)A &gt; B，子元素选择器：选中匹配 A父元素内的直接B子元素A + B，直接相邻选择器：选中匹配 B 元素之后的相邻的同级的A元素A ~ B，普通相邻选择器：选中B元素之后的同级 A 元素（无论直接相邻与否）.a.b,匹配class=’’a b”元素A.b,匹配class=”a”的元素 ##四、伪类选择器 ###伪类与伪元素的区别:css引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用来修饰不在文档树中的部分，比如，一句话中的第一个字母，或者是列表中的第一个元素。下面分别对伪类和伪元素进行解释： 伪类用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的元素时，我们可以通过:hover来描述这个元素的状态。虽然它和普通的css类相似，可以为已有的元素添加样式，但是它只有处于dom树无法描述的状态下才能为元素添加样式，所以将其称为伪类。 伪元素用于创建一些不在文档树中的元素，并为其添加样式。比如说，我们可以通过:before来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。 ###1、动态伪类选择器：a:link ，匹配所有未被点击的链接a:visited ，匹配所有已被点击的链接a:hover ，匹配鼠标悬停其上的a元素a:active ，匹配鼠标已经其上按下、还没有释放的a元素E :focus ,选择获取焦点的输入字段 ###2：UI元素伪类选择器：E:checked ： {attribute}，匹配所有用户界面（form表单）中处于选中状态的元素EE:enabled ： {attribute}，匹配所有用户界面（form表单）中处于可用状态的E元素E:disabled ： {attribute}，匹配所有用户界面（form表单）中处于不可用状态的E元素E::selection ： {attribute}，匹配E元素中被用户选中或处于高亮状态的部分 ###3：结构伪类选择器：:root()选择器，从字面上我们就可以很清楚的理解是根选择器，他的意思就是匹配元素E所在文档的根元素。在HTML文档中，根元素始终是。“:root”选择器等同于元素:not()选择器称为否定选择器，和jQuery中的:not选择器一模一样，可以选择除某个元素之外的所有元素。:empty()选择器表示的就是空。用来选择没有任何内容的元素，这里没有内容指的是一点内容都没有，哪怕是一个空格。:target()选择器来对页面某个target元素(该元素的id被当做页面中的超链接来使用)指定样式，该样式只在用户点击了页面中的超链接，并且跳转到target元素后起作用:first-child()选择器表示的是选择父元素的第一个子元素的元素E。简单点理解就是选择元素中的第一个子元素 : last-child匹配元素的最后一个子元素。:nth-child根据元素的位置匹配一个或者多个元素（它接受一个an+b形式的参数，an+b匹配到的元素示例如下：1n+0，或n，匹配每一个子元素。2n+0，或2n，匹配位置为2、4、6、8…的子元素，该表达式与关键字even等价。2n+1匹配位置为1、3、5、7…的子元素、该表达式与关键字odd等价。3n+4匹配位置为4、7、10、13…的子元素。）:nth-last-child()从某父元素的最后一个子元素开始计算，来选择特定的元素：first-of-type匹配属于其父元素的首个特定类型的子元素的元素。:nth-of-type与nth-child相似，不同之处在于它是只匹配特定类型的元素。 ##五、伪元素选择器 ##伪元素概念：伪元素用于创建一些不在文档树中的元素，并为其添加样式。比如说，我们可以通过:before来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。 E::before在被选元素前插入内容。需要使用content属性来指定要插入的内容。被插入的内容实际上不在文档树中。E::after在被元素后插入内容，其用法和特性与:before相似E::first-letter匹配元素中文本的首字母。被修饰的首字母不在文档树中。E:first-line匹配元素中第一行的文本。这个伪元素只能用在块元素中，不能用在内联元素中。E::selection匹配用户被用户选中或者处于高亮状态的部分。E::placeholder匹配占位符的文本，只有元素设置了placeholder属性时，该伪元素才能生效 ##计算选择器的优先级 ###简单情况： #####优先级从高到低分别是：在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式作为style属性写在元素标签上的内联样式Id选择器类选择器伪类选择器属性选择器标签选择器通配符选择器浏览器自定义 ###复杂场景：如有多种选择器组合使用，同时选中某元素，直接计算a,b,c,d的值行内样式 ==&gt; aID 选择器 ==&gt; b类，属性选择器和伪类选择器 ==&gt; c标签选择器、伪元素 ==&gt; dabcd优先级依次降低 ##范例 123456789101112131415161718192021222324&lt;style&gt; .box:first-child &#123; color: red;&#125;.box:first-of-type &#123; background: blue;&#125;.box :first-child &#123; font-size: 30px;&#125;.box :first-of-type &#123; font-weight: bold;&#125; &lt;/style&gt; &lt;div class="container"&gt; &lt;div class="box"&gt;div.box&lt;/div&gt; &lt;p class="box"&gt;p.box&lt;/p&gt; &lt;div class="box"&gt;div.box&lt;/div&gt; &lt;div class="box"&gt; &lt;div class="item"&gt;div.item&lt;/div&gt; &lt;p class="item"&gt;p.item&lt;/p&gt; &lt;/div&gt; &lt;p class="box"&gt;&lt;/p&gt; &lt;/div&gt; .box:first-child {color: red;}选择其父元素的第一个class=”.box”的子元素为红色，选中的是 div.box并让其字体颜色为红色 .box:first-of-type {background: blue;}选择其父元素中指定的某种类型且class=”.box”的子元素的背景颜色为蓝色，选中的是 div.box，p.box，并让其背景颜色为蓝色 .box :first-child {font-size: 30px;}选择class=”box”父元素内的第一个子元素的字体为30px,选中的是 div.item，并让其字体大小为30px; .box :first-of-type {font-weight: bold;}选择claa=”box”父元素内的第一个某种类型的子元素的字体加粗，选中的是 div.itemp.item，并让其字体加粗]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[form表单]]></title>
    <url>%2F2018%2F03%2F17%2Fform%E8%A1%A8%E5%8D%95%2F</url>
    <content type="text"><![CDATA[##post 和 get 方式提交数据有什么区别 1.最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数; 2.GET能被缓存，POST不能缓存 。 3.GET历史参数保留在浏览器历史中。POST参数不会保存在浏览器历史中。 4.GET对数据长度有限制，当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。POST无限制。 5.GET只允许 ASCII 字符。POST没有限制。也允许二进制数据。 6 与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。GET的数据在 URL 中对所有人都是可见的。POST的数据不会显示在 URL 中。 7.GET方法请求资源。POST的语义是上传数据。 8.POST不安全，不幂等， ##在input里，name 有什么作用？ 用途1： name 属性用于对提交到服务器后的表单数据进行标识，或者在客户端通过 JavaScript 引用表单数据。只有设置了 name 属性的表单元素才能在提交表单时传递它们的值。比如input、select、textarea、和button等。我们可以在服务器端根据其Name通过Request.Params取得元素提交的值。 用途2： HTML元素Input type=’radio’分组，我们知道radio button控件在同一个分组类，check操作是mutex的，同一时间只能选中一个radio，这个分组就是根据相同的Name属性来实现的。##placeholder 属性有什么作用？ 该提示会在输入字段为空时显示，并会在字段获得焦点时消失。 ##label 有什么作用？如何使用？ 标签为 input 元素定义标注（标记）。 label 元素不会向用户呈现任何特殊效果。不过，它为鼠标用户改进了可用性。如果您在 label 元素内点击文本，就会触发此控件。就是说，当用户选择该标签时，浏览器就会自动将焦点转到和标签相关的表单控件上。 标签的 for 属性应当与相关元素的 id 属性相同。1234&lt;div class="username"&gt;&lt;label for="username"&gt;姓名&lt;/label&gt;&lt;input id="username" type="text" name="username"/&gt;&lt;/div&gt; ###type=hidden隐藏域有什么作用? 1.隐藏域的作用是帮助表单收集和发送信息，便于后端处理数据。用户点击提交数据的时候，隐藏域的信息也被一起发送到了后端。 2.后端接收前端传来的数据，需要确认前端的身份，是本公司的网页传来的数据，而不是其他黑客知道后端地址后传来的假数据。那么就加一个隐藏域，验证value里的值和数据库里name的值是不是对应的。 3.有时候一个表单里有多个提交按钮，后端怎么知道用户是点击哪个按钮提交过来的呢？这时候我们只要加隐藏域，对每一个按钮起个名字(value值)，后端接收到数据后，检查value值，就能知道是哪个按钮提交的了。 4.有时候一个网页中有多个form，我们知道多个form是不能同时提交的，但有时这些form确实相互作用，我们就可以在form中添加隐藏域来使它们联系起来。 5.防范CRSF攻击 #5.表单范例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="login"&gt; &lt;form action="/getInfo" method="post"&gt; &lt;div class="username"&gt; &lt;label for="username"&gt;姓名：&lt;/label&gt; &lt;input id="username" type="text" name="username" placeholder="用户名"/&gt; &lt;/div&gt; &lt;div class="password"&gt; &lt;label for="password"&gt;密码：&lt;/label&gt; &lt;input id="password" type="password" name="password" placeholder="请输入密码" value="56767889"/&gt; &lt;/div&gt; &lt;div class="sex"&gt; &lt;label for=""&gt;性别&lt;/label&gt; &lt;input type="radio" name="sex1" value="男" checked/&gt;男 &lt;input type="radio" name="sex1" value="女"/&gt;女 &lt;/div&gt; &lt;div class="sex"&gt; &lt;label for=""&gt;取向&lt;/label&gt; &lt;input type="radio" name="sex2" value="男" /&gt;男 &lt;input type="radio" name="sex2" value="女" checked/&gt;女 &lt;/div&gt; &lt;div class="hobby"&gt; &lt;label &gt;爱好&lt;/label&gt; &lt;input type="checkbox" name="hobby" value="data"/&gt;data &lt;input type="checkbox" name="hobby" value="旅游" checked/&gt;旅游 &lt;input type="checkbox" name="hobby" value="宠物" checked/&gt;宠物 &lt;/div&gt; &lt;div class="textarea"&gt; &lt;label for=" review"&gt;评论：&lt;/label&gt; &lt;textarea name="review" id=" review" cols="30" rows="10"&gt; ddd &lt;/textarea&gt; &lt;input type="hidden" name="csrf" value="123456"/&gt; &lt;/div&gt; &lt;div class="select"&gt; &lt;label for="car"&gt;我的car:&lt;/label&gt; &lt;select name="car" id="car"&gt; &lt;option selected value="萨博" &gt;萨博&lt;/option&gt; &lt;option value="奔驰"&gt;奔驰&lt;/option&gt; &lt;option value="宝马"&gt;宝马&lt;/option&gt; &lt;/select&gt; &lt;span class="submit"&gt; &lt;input type="submit" value="提交"&gt; &lt;/span&gt; &lt;/div&gt; &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“事件循环：微任务 宏任务”]]></title>
    <url>%2F2018%2F03%2F14%2F%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%9A%E5%BE%AE%E4%BB%BB%E5%8A%A1%20%E5%AE%8F%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[#前提：JavaScript引擎有一个监听事件（monitoring process）的功能，会持续不断的检查js引擎的主线程执行栈是否为空，如果为空就会去取事件触发线程存放在事件队列中的回调函数执行。 #micro task 和 macro task 浏览器的事件循环依靠已事件队列，但是一个进程中不止一个事件队列，大致可以分为micro task和macro task，常见的微任务和宏任务分别包括： ##micro task ： nextTick callback Promise process.nextTick Object.observe MutationObserver macro task：-setTimeout setInterval I/O script代码块event loop 事件队列在同步队列执行完后，首先会执行nextTick，等nextTick执行完成后， 然后会先执行micro task， 等micro task队列空了之后，才会去执行macro task， 如果中间添加了micro task加入了micro task队列，会继续去执行micro task队列，然后再回到macro task队列。 注意：一段代码块就是一个宏任务。所有一般执行代码块的时候，也就是程序执行进入主线程了，主线程会根据不同的代码再分微任务和宏任务等待主线程执行完成后，不停地循环执行。主线程（宏任务） =&gt; 微任务 =&gt; 宏任务 =&gt; 主线程 ##范例：12345678910111213141516171819setTimeout( () =&gt; console.log('timeout'))new Promise(function(resolve) &#123; for(var i = 0; i &lt; 10; i++) &#123; resolve(); &#125; console.log('a');&#125;).then(function() &#123; console.log('promise');&#125;)console.log('c');"a""c""promise""timeout" 1.当前task运行，执行代码。首先setTimeout的callback被添加到tasks queue中；2.实例化promise，输出 a;3.promise.then的callback被添加到microtasks queue中；4.输出”c” ;5.已到当前task的end，执行microtasks，输出”promise” ;6.执行下一个task，输出”timeout”。 #总结：1.主线程（宏任务） =&gt; 微任务 =&gt; 宏任务 =&gt; 主线程2.微任务会被添加到一轮事件循环的尾部执行，就是吊车尾啦比如promise；3.宏任务则被添加下一轮事件循环，主线程同步任务以被清空后执行。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象]]></title>
    <url>%2F2018%2F03%2F09%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[JS 中的对象JS 中的对象是一系列无序 key: value 的集合 比如1234567var obj = &#123; a: 1, b: 2&#125;var person = &#123; name: 'hunger', sayName: function()&#123; console.log('My name is hunger') &#125;&#125; 我们可以通过 对象.属性来获取对应属性的值12345678910console.log(person.name)person.sayName()但假设我们定义一个函数function sum(a, b)&#123; return a + b&#125;console.log(sum.name) // =&gt; sumconsole.log(sum.length) //2 构造对象我们可以抛开类，使用字面量来构造一个对象 1234567891011121314var obj1 = &#123; nick: 'Byron', age: 20, printName: function()&#123; console.log(obj1.nick); &#125;&#125;var obj2 = &#123; nick: 'Casper', age: 25, printName: function()&#123; console.log(obj2.nick); &#125;&#125; 问题： 太麻烦了，每次构建一个对象都是复制一遍代码 如果想个性化，只能通过手工赋值，使用者必需了解对象详细 使用函数做自动化12345678910111213function createObj(nick, age)&#123; var obj = &#123; nick: nick, age: age, printName: function()&#123; console.log(this.nick); &#125; &#125;; return obj;&#125;var obj3 = createObj('Byron', 30);obj3.printName(); 通过创建一个函数来实现自动创建对象的过程，至于个性化通过参数实现，开发者不必关注细节，只需要传入指定参数即可 构造函数 任何函数使用new表达式就是构造函数 每个函数都自动添加一个名称为prototype属性，这是一个对象 每个对象都有一个内部属性 __proto__(规范中没有指定这个名称，但是浏览器都这么实现的) 指向其类型的prototype属性，类的实例也是对象，其__proto__属性指向“类”的prototype 123456789function Modal(msg)&#123; this.msg = msg&#125;var modal = new Modal()undefinedmodalModal &#123;msg: undefined&#125;msg: undefined__proto__: Objectconstructor: ƒ Modal(msg)__proto__: Objectmodal.msgundefined 过程：1.创建了一个空对象{}，并把这个空对象的proto指向Modal.prototype. 2.执行函数Modal(），执行过程中对 this 操作就是对 新创建对象 进行操作，未传入传输，可理解为传入值为undefined，然后这个对象的msg ：undefined； 3.函数执行完后返回这个对象，然后把这个对象赋值给modal； instanceofinstanceof是一个操作符，可以判断对象是否为某个类型的实例 12modal instanceof Modal( ; // truemodal instanceof Object;// true instanceof判断的是对象 11 instanceof Number; // false]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包与作用域]]></title>
    <url>%2F2018%2F03%2F06%2F%E9%97%AD%E5%8C%85%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[#什么是闭包： 闭包是函数和函数声明所在其词法作用域的组合(MDN) 函数连同它作用域链上的要找的这个变量，共同构成闭包 看懂之前博客理解作用域 函数在执行的过程中，先从自己内部找变量 如果找不到，再从创建当前函数所在的作用域(词法作用域)去找, 以此往上 注意找的是变量的当前的状态列如：12345678function init() &#123; var name = xiaohui"; // name 是一个被 init 创建的局部变量 function displayName() &#123; // displayName() 是内部函数,一个闭包 alert(name); // 使用了父函数中声明的变量 &#125; displayName();&#125;init(); 这就是一个闭包函数模型方式1234567891011function fn1()&#123; let i = 1; return function()&#123; i+=1; console.log(i); &#125;&#125;let add=fn1();add();//2add();//3add();//4 对象模型方式1234567891011121314function createNumber()&#123; let num= 1; return &#123; getnum:()=&gt;&#123; return num; &#125;, setnum:(value)=&gt;&#123; num = value; &#125; &#125;&#125;var n = createNumber();n.setnum(2);console.log(n.getnum()) 一般情况下使用闭包主要是为了 封装数据 暂存数据` 案例理解了下面几个案例，你就能熟练理解运用闭包了 如下代码输出多少？如果想输出3，那如何改造代码？1234567var fnArr = [];for (var i = 0; i &lt; 10; i ++) &#123; fnArr[i] = function()&#123; return i &#125;;&#125;console.log( fnArr[3]() ) //10 闭包123456789var fnArr = [];for(var i=0 ;i&lt;10;i++)&#123; fnArr[i]=(function(j)&#123; return function()&#123; return j; &#125; &#125;(i));&#125;console.log(fnArr[3]()); 立即执行函数123456789var fnArr = [];for(var i=0;i&lt;10;i++)&#123; ( function(i)&#123; fnArr[i]= function()&#123; return i; &#125; &#125;(i))&#125;console.log(fnArr[3]()); es61234567var fnArr = [];for(let i = 0;i&lt;10;i++)&#123; fnArr[i]=function()&#123; return i; &#125;&#125;console.log(fnArr[3]()); 封装一个 Car 对象。123456789101112131415161718192021var Car = (function()&#123; var speed = 0; function set(s)&#123; speed=s; &#125; function get()&#123; return speed; &#125; function speedUp()&#123; speed++; &#125; function speedDown()&#123; speed--; &#125; return &#123; set: set, get: get, speedUp: speedUp, speedDown: speedDown &#125;&#125;)() 如下代码输出多少？如何连续输出 0,1,2,3,4？12345for(var i=0; i&lt;5; i++)&#123; setTimeout(function()&#123; console.log('delayer:' + i ) &#125;, 0)&#125; //5 5 5 5 5; 1234567for(var i=0; i&lt;5; i++)&#123; (function(j)&#123; setTimeout(function()&#123; console.log('delayer:' + j ) &#125;, 0) &#125;(i))&#125; 12345678for (var i=0;i&lt;5;i++)&#123; setTimeout((function (j) &#123; return function()&#123; console.log('delayer:'+j) &#125; &#125;(i)) ,0)&#125; 如下代码输出多少？12345678910111213141516function makeCounter() &#123; var count = 0; return function() &#123; return count++ &#125;;&#125;var counter = makeCounter();console.log(counter());\\0console.log(counter());\\1console.log(counter());\\2console.log(counter());\\3var counter2 = makeCounter();console.log(counter2());\\0console.log(counter2());\\1console.log(counter2());\\2console.log(counter2());\\3 补全代码，实现数组按姓名、年纪、任意字段排序1234567891011121314151617181920212223242526var users = [ &#123; name: "John", age: 20, company: "Baidu" &#125;, &#123; name: "Pete", age: 18, company: "Alibaba" &#125;, &#123; name: "Ann", age: 19, company: "Tecent" &#125;]function byName(v1,v2)&#123; return v1.name&gt;v2.name;&#125;function byAge(v1,v2)&#123; return v1.age&gt;v2.age;&#125;function byCompany(v1,v2)&#123; return v1.company&gt;v2.company;&#125;function byField(field)&#123; return function(v1,v2)&#123; return v1[field]&gt;v2[field] &#125;&#125;console.log(users.sort(byName))console.log(users.sort(byAge))console.log(users.sort(byCompany))console.log(users.sort(byField('age')))console.log(users.sort(byField('company'))) 写一个 sum 函数，实现如下调用方式123456function sum(a)&#123;return function(b)&#123;return a+b;&#125;&#125;console.log(sum(1)(2))]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“JS 类型隐式转换”]]></title>
    <url>%2F2018%2F03%2F05%2F%E2%80%9CJS%20%E7%B1%BB%E5%9E%8B%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E2%80%9D%2F</url>
    <content type="text"><![CDATA[##1、js数据类型js中有7种数据类型，可以分为两类：原始类型、对象类型： 基础类型(原始值)： Undefined、 Null、 String、 Number、 Boolean、 Symbol (es6新出的，本文不讨论这种类型)复杂类型(对象值)： object #2、三种隐式转换类型js中一个难点就是js隐形转换，因为js在一些操作符下其类型会做一些变化，所以js灵活，同时造成易出错，并且难以理解。 涉及隐式转换最多的两个运算符 + 和 ==。 +运算符即可数字相加，也可以字符串相加。所以转换时很麻烦，有些也比较难理解：1234567891011121314151617181920212223242526[]+&#123;&#125;"[object Object]"&#123;&#125;+[]"a"+[]"a""a"+&#123;&#125;"a[object Object]"1+[]"1"1+&#123;&#125;"1[object Obje01+'0'"10"null+11null+"q""nullq"undefined+1NaNundefined+"b""undefinedb"NaN+1NaNNaN+"c""NaNc" == 不同于===，故也存在隐式转换。12345678910111213141516undefined==nulltruenull==1falsenull==0falseundefined==1falseundefined==0false[1]==1truevar a=&#123;1:1&#125;undefineda==1false / 这些运算符只会针对number类型，故转换的结果只能是转换成number类型,比较简单。 #既然要隐式转换，那到底怎么转换呢，应该有一套转换规则，才能追踪最终转换成什么了。 隐式转换中主要涉及到三种转换：1、将值转为原始值，ToPrimitive()。 2、将值转为数字，ToNumber()。 3、将值转为字符串，ToString()。 2.1、通过ToPrimitive将值转换为原始值js引擎内部的抽象操作ToPrimitive有着这样的签名： ToPrimitive(input, PreferredType?) input是要转换的值，PreferredType是可选参数，可以是Number或String类型。他只是一个转换标志，转化后的结果并不一定是这个参数所值的类型，但是转换结果一定是一个原始值（或者报错）。 ##2.1.1、如果PreferredType被标记为Number，则会进行下面的操作流程来转换输入的值。1、如果输入的值已经是一个原始值，则直接返回它2、否则，如果输入的值是一个对象，则调用该对象的valueOf()方法， 如果valueOf()方法的返回值是一个原始值，则返回这个原始值。3、否则，调用这个对象的toString()方法，如果toString()方法返回的是一个原始值，则返回这个原始值。4、否则，抛出TypeError异常。 ##2.1.2、如果PreferredType被标记为String，则会进行下面的操作流程来转换输入的值。1、如果输入的值已经是一个原始值，则直接返回它2、否则，调用这个对象的toString()方法，如果toString()方法返回的是一个原始值，则返回这个原始值。3、否则，如果输入的值是一个对象，则调用该对象的valueOf()方法， 如果valueOf()方法的返回值是一个原始值，则返回这个原始值。4、否则，抛出TypeError异常。 ##既然PreferredType是可选参数，那么如果没有这个参数时，怎么转换呢？ PreferredType的值会按照这样的规则来自动设置： 1、该对象为Date类型，则PreferredType被设置为String 2、否则，PreferredType被设置为Number ##2.1.3、valueOf方法和toString方法解析 ##上面主要提及到了valueOf方法和toString方法，那这两个方法在对象里是否一定存在呢？答案是肯定的。在控制台输出Object.prototype，你会发现其中就有valueOf和toString方法，而Object.prototype是所有对象原型链顶层原型，所有对象都会继承该原型的方法，故任何对象都会有valueOf和toString方法。 ##对象的valueOf函数，其转换结果是什么？对于js的常见内置对象：Date, Array, Math, Number, Boolean, String, Array, RegExp, Function。 1、Number、Boolean、String这三种构造函数生成的基础值的对象形式，通过valueOf转换后会变成相应的原始值。如：123456var num = new Number('123');num.valueOf(); // 123var str = new String('12df');str.valueOf(); // '12df'var bool = new Boolean('fd');bool.valueOf(); // true ###2、Date这种特殊的对象，其原型Date.prototype上内置的valueOf函数将日期转换为日期的毫秒的形式的数值。12var a = new Date();a.valueOf(); // 1532234132475 3、除此之外返回的都为this，即对象本身：123456var a = new Array();a.valueOf() === a;// truevar b = new Object(&#123;&#125;);b.valueOf() === b; // true ##toString函数，其转换结果是什么？ 对于js的常见内置对象：Date, Array, Math, Number, Boolean, String, Array, RegExp, Function。 1、Number、Boolean、String、Array、Date、RegExp、Function这几种构造函数生成的对象，通过toString转换后会变成相应的字符串的形式，因为这些构造函数上封装了自己的toString方法。如：12345678910111213141516171819202122Number.prototype.hasOwnProperty('toString'); // trueBoolean.prototype.hasOwnProperty('toString'); // trueString.prototype.hasOwnProperty('toString'); // trueArray.prototype.hasOwnProperty('toString'); // trueDate.prototype.hasOwnProperty('toString'); // trueRegExp.prototype.hasOwnProperty('toString'); // trueFunction.prototype.hasOwnProperty('toString'); // truevar num = new Number('123sd');num.toString(); // 'NaN'var str = new String('12df');str.toString(); // '12df'var bool = new Boolean('fd');bool.toString(); // 'true'var arr = new Array(1,2);arr.toString(); // '1,2'var d = new Date();d.toString(); // "Sun Jul 22 2018 12:38:42 GMT+0800 (中国标准时间)"var func = function () &#123;&#125;func.toString(); // "function () &#123;&#125;"var obj = new Object(&#123;&#125;);obj.toString(); // "[object Object]"Math.toString(); // "[object Math]" ##除这些对象及其实例化对象之外，其他对象返回的都是该对象的类型，都是继承的Object.prototype.toString方法。 ##从上面valueOf和toString两个函数对对象的转换可以看出为什么对于ToPrimitive(input, PreferredType?) ####PreferredType没有设定的时候，除了Date类型，PreferredType被设置为String，其它的会设置成Number。 因为valueOf函数会将Number、String、Boolean基础类型的对象类型值转换成 基础类型，Date类型转换为毫秒数，其它的返回对象本身. 而toString方法会将所有对象转换为字符串。 显然对于大部分对象转换，valueOf转换更合理些，因为并没有规定转换类型，应该尽可能保持原有值，而不应该想toString方法一样，一股脑将其转换为字符串。 所以对于没有指定PreferredType类型时，先进行valueOf方法转换更好，故将PreferredType设置为Number类型。 而对于Date类型，其进行valueOf转换为毫秒数的number类型。在进行隐式转换时，没有指定将其转换为number类型时，将其转换为那么大的number类型的值显然没有多大意义。（不管是在+运算符还是==运算符）还不如转换为字符串格式的日期，所以默认Date类型会优先进行toString转换。故有以上的规则： PreferredType没有设置时，Date类型的对象，PreferredType默认设置为String，其他类型对象PreferredType默认设置为Number。 ##2.2、通过To Number将值转换为数字注意：12'12a'==12false #2.3、通过ToString将值转换为字符串根据参数类型进行下面转换：undefined ’undefined’null ’null’布尔值转换为’true’ 或 ‘false’数字转换字符串，比如：1.765转为’1.765’对象(obj)先进行 ToPrimitive(obj, String)转换得到原始值，在进行ToString转换为字符串讲了这么多，是不是还不是很清晰，先来看看一个例子：12(&#123;&#125; + &#123;&#125;)//[object Object] 两个对象的值进行+运算符，肯定要先进行隐式转换为原始类型才能进行计算。1、进行ToPrimitive转换，由于没有指定PreferredType类型，{}会使默认值为Number，进行ToPrimitive(input, Number)运算。2、所以会执行valueOf方法，({}).valueOf(),返回的还是{}对象，不是原始值。3、继续执行toString方法，({}).toString(),返回”[object Object]”，是原始值。故得到最终的结果，”[object Object]” + “[object Object]” = “[object Object][object Object]” 再来一个指定类型的例子：122 * &#123;&#125; //NaN 1、首先运算符只能对number类型进行运算，故第一步就是对{}进行ToNumber类型转换。2、由于{}是对象类型，故先进行原始类型转换，ToPrimitive(input, Number)运算。3、所以会执行valueOf方法，({}).valueOf(),返回的还是{}对象，不是原始值。4、继续执行toString方法，({}).toString(),返回”[object Object]”，是原始值。5、转换为原始值后再进行ToNumber运算，”[object Object]”就转换为NaN。故最终的结果为 2 NaN = NaN #3、== 运算符隐式转换 ##类型相同时，没有类型转换，主要注意NaN不与任何值相等，包括它自己，即NaN !== NaN。 ##==在比较的时候可以转换数据类型，若等式两边数据类型不相同，将会往数值类型方向转换后再进行比较1、x,y 为null、undefined两者中一个 // 返回true 2、x、y为Number和String类型时，则转换为Number类型比较。 3、有Boolean类型时，Boolean转化为Number类型比较。 4、一个Object类型，一个String或Number类型，将Object类型进行原始转换后，按上面流程进行原始值比较。 12345"" == 0 //ture" " == 0 //ture"" == true //false"" == false //ture" " == true //false 12345678" " == true //false" " == false //ture"hello" == true //false"hello" == false //false"0" == true //false"0" == false //true"00" == false //true"0.00" == false //true 12345678910undefined == null //ture true ==&#123;&#125; //false[] == true //falsevar obj = &#123; a: 0, valueOf: function()&#123;return 1&#125;&#125;obj == "[object Object]" //falseobj == 1 //trueobj == true //true ##注意1.==等好两边都为对象时，比较的是地址1234[]==[]false&#123;&#125;==&#123;&#125;false 2.对象转化成数值为NaN,数组则不一定。123456789101112let arr=[123]undefinedlet obj = &#123;123:123&#125;undefinedNumber(arr)123Number(obj)NaNobj == 123falsearr == 123true ###3.1、== 例子解析所以类型不相同时，可以会进行上面几条的比较，比如：123456789var a = &#123; valueOf: function () &#123; return1; &#125;, toString: function () &#123; return'123' &#125;&#125;true == a // true; boolean类型进行ToNumber转换为1object类型，对y进行原始转换，ToPrimitive(a, ?),没有指定转换类型，默认number类型。而后，ToPrimitive(a, Number)首先调用valueOf方法，返回1，得到原始类型1。最后 1 == 1， 返回true。 我们再看一段很复杂的比较，如下：12[] == !&#123;&#125;true 1、! 运算符优先级高于==，故先进行！运算。2、!{}运算结果为false，结果变成 [] == false比较。3、转换数字类型结果变成 [] == 0。比较变成ToPrimitive([]) == 0。 按照上面规则进行原始值转换，[]会先调用valueOf函数，返回this。 不是原始值，继续调用toString方法， [].toString() = ‘’。 故结果为 ‘’ == 0比较。5、 ToNumber(‘’) = 0。 所以结果变为： 0 == 0，返回true，比较结束。 最后看看这道题目： const a = { i: 1, toString: function () { return a.i++; }}if (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) { console.log(‘hello world!’);} 1、当执行a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3 时，会从左到右一步一步解析，首先 a == 1，会进行上面第9步转换。ToPrimitive(a， Number) == 1。 2、ToPrimitive(a, Number)，按照上面原始类型转换规则，会先调用valueOf方法，a的valueOf方法继承自Object.prototype。返回a本身，而非原始类型，故会调用toString方法。 3、因为toString被重写，所以会调用重写的toString方法，故返回1，注意这里是i++，而不是++i，它会先返回i，在将i+1。故ToPrimitive(a, Number) = 1。也就是1 == 1，此时i = 1 + 1 = 2。 4、执行完a == 1返回true，会执行a == 2，同理，会调用ToPrimitive(a, Number)，同上先调用valueOf方法，在调用toString方法，由于第一步，i = 2此时，ToPrimitive(a, Number) = 2， 也就是2 == 2, 此时i = 2 + 1。 5、同上可以推导 a == 3也返回true。故最终结果 a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3返回true 再比如：12345678&#123;&#125;+[]0[]+&#123;&#125;"[object Object]"0+&#123;&#125;"0[object Object]"&#123;&#125;+00 是因为{}可以是空块或空对象文字，具体取决于上下文。 可以是一元加运算符，也可以是连接运算符，具体取决于上下文。 第一个代码示例是一个空块，它可能也不存在，使表达式相同+[]，意思是“空数组转换为数字”。 你不能把一个块作为一个函数参数，所以第二个代码示例{}是一个对象，代码的意思是“用一个数组来传递一个对象”（隐式地将对象和数组转换为字符串）。换句话说，{} + []表达式是一个empty代码块，后面跟array一个数字（Number[]）的约束。 在第二个示例中，您只是向concat数组提供了一个对象文字（空对象）。这就是你收到的原因[object Object]。再比如：123456null==0falsenull==1false+null0 Null类型的比较不等于1或0（实际上，null仅与undefined 相当),但当强制转换ToNumber（null）===0； #最终null==undefined//true ,实在无法理解，暂时只能理解这就是个坑，强行死记硬背。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM动态集合]]></title>
    <url>%2F2018%2F02%2F03%2FDOM%E5%8A%A8%E6%80%81%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[##DOM是JavaScript中重要部分之一，在DOM中有一个动态集合。这个动态集合包含节点的集合（NodeList）、元素属性的集合（NamedNodeMap）和HTML元素的集合（HTMLCollection）。这三个对象都是类数组（Array-like），具有像数组一样的特性 ##类数组：比如arguments 具有：指向对象元素的数字索引下标以及length属性告诉我们对象的元素个数 不具有：不具有诸如push()、forEach()以及indexOf()等数组对象具有的方法##将类数组对象转换为数组123456//es5let arr = Array.prototype.slice.call(arguments);//es6let arr = Array.from(arguments);//还可以使用ES6中的扩展运算符...将某些数据结构转换成数组，这种数据结构必须有遍历器接口。let arr = [...arguments]; ##NodeList集合 NodeList实例是一个类似数组的对象，它的成员是节点对象。通过以下方法可以得到NodeList实例。Node.childNodesdocument.querySelectorAll()、#HTMLCollection 一个节点对象的集合，只能包含元素节点（element），不能包含其他类型的节点。 HTMLCollection的集合可以通过getElementsByTagName()、getElementsByName()、document.getElementsByClassName()、document.anchors、document.forms、document.images和documnet.links等方式来获取。NameNodeMap集合DOM中的Element节点是唯一拥有attributes属性的一种节点类型。而attributes属性中就包含NamedNodeMap集合。NamedNodeMap集合的元素拥有nodeName和nodeValue属性，分别表示元素节点名称和值。三者的异同##共同点 三者都具有length属性 三者都有item()方法 三者都是动态的，如果对NodeList和HTMLCollection中的元素进行操作都会直接反映到DOM中，因此如果一次性直接在集合中进行DOM操作，开销非常大 不同之处： NodeList里面包含了所有的节点类型 HTMLCollection里面只包含元素节点 NamedNodeMap里面包含了Attribute的集合，例如id、title、class等，集合中的每一个元素都是attr类型 三者所提供的方法也有不同，例如HTMLCollection中提供了namedItem()，而NodeList和NamedNodeMap两个集合中没有namedItem()方法 动态NodeList和静态NodeList getElementsByTagName()方法返回一个动态（live）的HTMLCollection， 而querySelectorAll()返回的是一个静态（static）的NodeList##动态集合DOM中的NodeList和NamedNodeMap对象是动态的；也就是说，对底层文档结构的修改会动态地反映到相关的集合NodeList和NamedNodeMap中。例如，如果先获取了某个元素（Element）的子元素的动态集合NodeList对象，然后又在其他地方顺序添加更多子元素到这个DOM父元素中（可以说添加、修改、删除子元素等操作），这些更改将自动反射到NodeList，不需要手动进行其他调用。同样地，对DOM树上某个Node节点的修改，也会实时影响引用了该节点的NodeList和NamedNodeMap对象。##静态集合querySelectorAll()方法返回的NodeList对象必须是静态的，而不能是动态的。后续对底层document的更改不能影响到返回的这个NodeList对象。这意味着返回的对象将包含在创建列表那一刻匹配的所有元素节点123456789101112131415&lt;html&gt; &lt;head&gt; &lt;title&gt;DOM Tree&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="box"&gt; &lt;div&gt;Title&lt;/div&gt; &lt;div class="item"&gt;Item1&lt;/div&gt; &lt;div class="item"&gt;Item2&lt;/div&gt; &lt;div class="item"&gt;Item3&lt;/div&gt; &lt;div class="item"&gt;Item4&lt;/div&gt; &lt;div class="item"&gt;Item5&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 1234567891011121314let box = document.getElementById('box')let liveNodeList1 = document.getElementsByTagName('div')console.log(liveNodeList1)let liveNodeList2 = document.getElementsByClassName('.item')console.log(liveNodeList2)let liveNodeList3 = document.querySelectorAll('.item')console.log(liveNodeList3)let children = box.childNodes;console.log(children, children.length) #为什么动态集合比静态集合更快 ##为什么说getElementsByTagName()在所有浏览器上都比auerySelectorAll()要快好多倍。 让 querySelectorAll() 和 getElementsByTagName() 具有相同的参数和行为, 但有很大的不同点。 在前一种情况下, 返回的 NodeList 就是方法被调用时刻的文档状态的快照, 而后者总是会随时根据document的状态而更新 使用getElementsByTagName()方法我们得到的结果就像是一个对象的索引，而通过querySelectorAll()方法我们得到的是一个对象的克隆；所以当这个对象数据量非常大的时候，显然克隆这个对象所需要花费的时间是很长的1234567891011let box = document.getElementById('box')let liveNodeList = document.getElementsByTagName('div')console.log(liveNodeList, liveNodeList.length)let newEle = document.createElement('div')newEle.textContent = '新创建的div元素'box.appendChild(newEle)console.log(liveNodeList, liveNodeList.length) 1234567891011121314let box = document.getElementById('box')let liveNodeList = document.querySelectorAll('div')console.log(liveNodeList, liveNodeList.length)let newEle = document.createElement('div')newEle.textContent = '新创建的div元素'box.appendChild(newEle)console.log(liveNodeList, liveNodeList.length)liveNodeList = document.querySelectorAll('div')console.log(liveNodeList, liveNodeList.length)]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从URL输入到页面展现]]></title>
    <url>%2F2018%2F02%2F03%2F%E4%BB%8EURL%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[#前言当用户打开浏览器，在地址栏输入 https://www.baidu.com/，按下回车，页面展示百度首页。整个过程发生了什么呢？ #一、输入URL URL统一资源定位符，也平时我们说的网址。浏览器通过URL来查找和定位资源的位置。 url的格式一般为： 协议类型://&lt;服务器地址&gt;:&lt;服务器端口号&gt;/&lt;文件路径&gt;/ ####常见的协议有http、https、telnet、ftp、file等。 其中http是最常见的超文本传输协议 而https（超文本传输安全协议）则是由http通过与SSL （安全套接层）或TLS（安全传输协议）的组合使用，加密的HTTP的通信内容。因此HTTPS比HTTP协议更加安全。 ####服务器地址是URL指定待访问的地址。可以是域名或主机号，或ip地址 ####服务器端口号指服务器连接的网络端口号。若用户省去，则为默认端口号 因为一台计算机常常会同时作为Web，FTP等服务器，端口编号用来告诉web服务器所在的主机要将请求交给哪个服务。 默认情况下http服务的端口为80。ftp为21，HTTPS为443，telnet为23. ####文件路径则是服务器上文件路径定位上的资源，也就是目录 https://www.baidu.com/使用的是HTTPS协议，服务器地址则是域名。 ##二、域名解析 DNS服务是提供域名到IP地址之间的解析服务。计算机即可以被赋予ip地址，也可以被赋予主机号和域名，比如www.baidu.com。 用户通常使用主机号与域名来访问其他计算机，因为更容易记忆。 IP地址是指互联网协议地址，每个处于互联网中的设备都有IP 地址，形如192.168.1.10 局域网 IP 和公网 IP 是有差别的 127.0.0.1代表本机的 IP 当用户在浏览器中输入https://www.baidu.com/后,你使用的计算机会发出一个DNS请求到本地DNS服务器。本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动,中国联通DNS请求到达本地DNS服务器之后会有以下几个步骤 ####1 搜索浏览器缓存浏览器会缓存DNS记录一段时间，且有数量限制 ####2 搜索操作系统缓存从 Hosts 文件查找是否有该域名与对应 IP ####3 搜索路由器缓存一般路由器也会缓存域名信息 ####4搜索ISP(互联网服务提供商）NDS缓存比如到中国移动的 DNS 上查找缓存 ####5若都没有找到，则向根域名服务器查找域名对应 IP，根域名服务器把请求转发到下一级，直到找到对应IP ##三 .TCP连接 拿到域名对应的IP地址之后，指浏览器会以一个随机端口（1024 &lt; 端口 &lt; 65535）向服务器的WEB程序（常用的有httpd,nginx等）80端口发起TCP的连接请求。 3次握手，详细展开很麻烦的 ##四. 建立TCP连接后发起http请求、进过TCP3次握手之后，浏览器发起了http的请求，使用的http的方法 一般是GET 方法，请求的URL是 / ,协议是HTTP/1.0或HTTP/1.1 ##五、 服务器处理 ——响应http请求，响应报文 每台服务器上都会安装处理请求的应用——web server。常见的web server产品有apache、nginx、IIS或Lighttpd等。 当web server接收到一个HTTP请求，会返回一个HTTP响应，例如送回一个HTML页面。对于不同用户发送的请求，会结合配置文件，把不同请求委托给服务器上处理对应请求的程序进行处理 这些服务器端(server-side)的程序通常产生一个HTML的响应(response)来让浏览器可以浏览。 那么如何处理请求？实际上就是后台处理的工作。后台开发现在有很多框架，但大部分都还是按照MVC设计模式进行搭建的。####MVC是三个单词的首字母缩写，它们是Model（模型）、View（视图）和Controller（控制器）。1.最上面的一层，是直接面向最终用户的”视图层”（View）。视图是用户看到并与之交互的界面。这是前端工作的主力部分 2.模型（Model），模型是将实际开发中的业务规则和所涉及的数据格式模型化，应用于模型的代码只需写一次就可以被多个视图重用。在MVC的三个部件中，模型拥有最多的处理任务。一个模型能为多个视图提供数据。 3.控制器接受用户的输入并调用模型和视图去完成用户的需求。Controller处于管理角色，从视图接收请求并决定调用哪个模型构件去处理请求，然后再确定用哪个视图来显示模型处理返回的数据。 总结而言，首先控制器接收用户的请求，并决定应该调用哪个模型来进行处理，然后模型用业务逻辑来处理用户的请求并返回数据，最后控制器用相应的视图格式化模型返回html字符串给浏览器，浏览器呈现网页给用户。 ##七、浏览器处理——加载、解析、渲染接下来就是浏览器进行处理， 通过后台处理返回的HTML字符串被浏览器接受后被一句句读取解析，html页面经历加载、解析、渲染。 加载浏览器对一个html页面的加载顺序是从上而下的。如果加载过程中遇到外部css文件，浏览器另外发出一个请求，来获取css文件。遇到图片资源，浏览器也会另外发出一个请求，来获取图片资源。但是当文档加载过程中遇到js文件，html文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中js文件加载完毕，还要等待解析执行完毕，才可以恢复html文档的渲染线程。 解析 解析文档是指将文档转化成为有意义的结构，也就是可让代码理解和使用的结构。解析得到的结果通常是代表了文档结构的节点树，它称作解析树或者语法树，也就是DOM树。如下图： css解析是指将css文件解析为样式表对象。如下图： js解析是文件在加载的同时也进行解析详细的解析过程请看这###渲染即为构建渲染树的过程，就是将DOM树进行可视化表示。构建这棵树是为了以正确的顺序绘制文档内容。####八、绘制网页浏览器根据 HTML 和 CSS 计算得到渲染树，最终绘制到屏幕上 参看文章：前端经典面试题: 从输入URL到页面加载发生了什么？ 导航到某个网址时会发生什么？ 一次完整的HTTP事务是怎样一个过程？前端面试题：从url到页面展现，这之中发生了什么？在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？从URL输入到页面展现发生了什么？从URL输入到页面展现的过程-前端笔记浏览器工作原理：从 URL 输入到页面展现到底发生了什么？MVC模型结构是什么浏览器~加载，解析，渲染]]></content>
      <categories>
        <category>client</category>
      </categories>
      <tags>
        <tag>client</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo]]></title>
    <url>%2F2018%2F01%2F01%2Fhexo%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>server</category>
      </categories>
      <tags>
        <tag>server</tag>
      </tags>
  </entry>
</search>
